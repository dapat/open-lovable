"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/playground/page",{

/***/ "(app-pages-browser)/./app/utils/urlState.ts":
/*!*******************************!*\
  !*** ./app/utils/urlState.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildShareURL: () => (/* binding */ buildShareURL),\n/* harmony export */   encodeStateToQuery: () => (/* binding */ encodeStateToQuery),\n/* harmony export */   parseQueryToState: () => (/* binding */ parseQueryToState)\n/* harmony export */ });\n// Pure helpers for encoding/decoding Playground UI state into URL query strings.\n// No Next.js or DOM APIs used, safe for unit testing.\n/**\n * Build a URLSearchParams from UIState.\n * Notes:\n * - If autoStyle is true, theme and themeTokens are omitted (backend infers style from prompt).\n * - Undefined/empty values are omitted.\n */ function encodeStateToQuery(state) {\n    var _state_prompt;\n    const sp = new URLSearchParams();\n    const trimmedPrompt = (_state_prompt = state.prompt) === null || _state_prompt === void 0 ? void 0 : _state_prompt.trim();\n    if (trimmedPrompt) sp.set('prompt', trimmedPrompt);\n    if (typeof state.seed === 'number' && Number.isFinite(state.seed)) {\n        sp.set('seed', String(state.seed));\n    }\n    var _state_styleMode;\n    const mode = (_state_styleMode = state.styleMode) !== null && _state_styleMode !== void 0 ? _state_styleMode : state.autoStyle ? 'auto' : 'explicit';\n    const auto = mode === 'auto';\n    if (auto) {\n        sp.set('autoStyle', '1');\n        sp.set('styleMode', 'auto');\n    } else if (state.autoStyle === false) {\n        sp.set('autoStyle', '0');\n        sp.set('styleMode', mode);\n    }\n    // Only include theme/tokens when not in auto style mode\n    if (!auto && mode !== 'seeded') {\n        var _state_themeTokens, _state_themeTokens1, _state_themeTokens2;\n        if (state.theme) sp.set('theme', state.theme);\n        if ((_state_themeTokens = state.themeTokens) === null || _state_themeTokens === void 0 ? void 0 : _state_themeTokens.accent) sp.set('accent', state.themeTokens.accent);\n        if ((_state_themeTokens1 = state.themeTokens) === null || _state_themeTokens1 === void 0 ? void 0 : _state_themeTokens1.radius) sp.set('radius', state.themeTokens.radius);\n        if ((_state_themeTokens2 = state.themeTokens) === null || _state_themeTokens2 === void 0 ? void 0 : _state_themeTokens2.font) sp.set('font', state.themeTokens.font);\n    }\n    if (state.variationStrategy) {\n        sp.set('variationStrategy', state.variationStrategy);\n    }\n    // Return without leading \"?\"\n    return sp.toString();\n}\n/**\n * Parse query string or URLSearchParams into UIState.\n * - Accepts booleans as '1'/'0' or 'true'/'false' (case-insensitive).\n * - Coerces seed to number if finite; otherwise undefined.\n * - If autoStyle resolves to true, theme and themeTokens will be dropped.\n */ function parseQueryToState(qs) {\n    const sp = typeof qs === 'string' ? new URLSearchParams(qs.startsWith('?') ? qs.slice(1) : qs) : qs;\n    const getBool = (key)=>{\n        var _sp_get;\n        if (!sp.has(key)) return undefined;\n        const v = (_sp_get = sp.get(key)) === null || _sp_get === void 0 ? void 0 : _sp_get.toLowerCase();\n        if (v === '1' || v === 'true') return true;\n        if (v === '0' || v === 'false') return false;\n        return undefined;\n    };\n    const state = {};\n    var _sp_get;\n    const prompt = (_sp_get = sp.get('prompt')) !== null && _sp_get !== void 0 ? _sp_get : undefined;\n    if (prompt && prompt.trim().length > 0) state.prompt = prompt;\n    const seedRaw = sp.get('seed');\n    if (seedRaw != null && seedRaw !== '') {\n        const n = Number(seedRaw);\n        if (Number.isFinite(n)) state.seed = n;\n    }\n    const autoStyle = getBool('autoStyle');\n    if (typeof autoStyle !== 'undefined') state.autoStyle = autoStyle;\n    const styleMode = sp.get('styleMode') || null;\n    if (styleMode) state.styleMode = styleMode;\n    if (!styleMode && typeof state.autoStyle === 'boolean') {\n        state.styleMode = state.autoStyle ? 'auto' : 'explicit';\n    }\n    const theme = sp.get('theme');\n    var _sp_get1;\n    const accent = (_sp_get1 = sp.get('accent')) !== null && _sp_get1 !== void 0 ? _sp_get1 : undefined;\n    var _sp_get2;\n    const radius = (_sp_get2 = sp.get('radius')) !== null && _sp_get2 !== void 0 ? _sp_get2 : undefined;\n    const font = sp.get('font');\n    const variationStrategy = sp.get('variationStrategy');\n    if (variationStrategy) state.variationStrategy = variationStrategy;\n    // If autoStyle=true OR styleMode=seeded, ignore explicit theme/tokens (frontend will derive)\n    const allowExplicit = !(autoStyle === true || styleMode === 'seeded');\n    if (allowExplicit) {\n        if (theme) state.theme = theme;\n        const tokens = {};\n        if (accent) tokens.accent = accent;\n        if (radius) tokens.radius = radius;\n        if (font) tokens.font = font;\n        if (Object.keys(tokens).length > 0) state.themeTokens = tokens;\n    }\n    return state;\n}\n/**\n * Build a full shareable URL by appending the encoded query to a base URL.\n * If base already has a query, it will be replaced.\n */ function buildShareURL(baseUrl, state) {\n    const q = encodeStateToQuery(state);\n    const hasHash = baseUrl.includes('#') ? baseUrl.indexOf('#') : -1;\n    const [beforeHash, hash] = hasHash >= 0 ? [\n        baseUrl.slice(0, hasHash),\n        baseUrl.slice(hasHash)\n    ] : [\n        baseUrl,\n        ''\n    ];\n    const baseNoQuery = beforeHash.split('?')[0];\n    const sep = baseNoQuery.includes('?') ? '' : '?';\n    return \"\".concat(baseNoQuery).concat(sep).concat(q).concat(hash);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy91cmxTdGF0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpRkFBaUY7QUFDakYsc0RBQXNEO0FBc0J0RDs7Ozs7Q0FLQyxHQUNNLFNBQVNBLG1CQUFtQkMsS0FBYztRQUd6QkE7SUFGdEIsTUFBTUMsS0FBSyxJQUFJQztJQUVmLE1BQU1DLGlCQUFnQkgsZ0JBQUFBLE1BQU1JLE1BQU0sY0FBWkosb0NBQUFBLGNBQWNLLElBQUk7SUFDeEMsSUFBSUYsZUFBZUYsR0FBR0ssR0FBRyxDQUFDLFVBQVVIO0lBRXBDLElBQUksT0FBT0gsTUFBTU8sSUFBSSxLQUFLLFlBQVlDLE9BQU9DLFFBQVEsQ0FBQ1QsTUFBTU8sSUFBSSxHQUFHO1FBQ2pFTixHQUFHSyxHQUFHLENBQUMsUUFBUUksT0FBT1YsTUFBTU8sSUFBSTtJQUNsQztRQUVhUDtJQUFiLE1BQU1XLE9BQU9YLENBQUFBLG1CQUFBQSxNQUFNWSxTQUFTLGNBQWZaLDhCQUFBQSxtQkFBb0JBLE1BQU1hLFNBQVMsR0FBRyxTQUFTO0lBQzVELE1BQU1DLE9BQU9ILFNBQVM7SUFDdEIsSUFBSUcsTUFBTTtRQUNSYixHQUFHSyxHQUFHLENBQUMsYUFBYTtRQUNwQkwsR0FBR0ssR0FBRyxDQUFDLGFBQWE7SUFDdEIsT0FBTyxJQUFJTixNQUFNYSxTQUFTLEtBQUssT0FBTztRQUNwQ1osR0FBR0ssR0FBRyxDQUFDLGFBQWE7UUFDcEJMLEdBQUdLLEdBQUcsQ0FBQyxhQUFhSztJQUN0QjtJQUVBLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNHLFFBQVFILFNBQVMsVUFBVTtZQUUxQlgsb0JBQ0FBLHFCQUNBQTtRQUhKLElBQUlBLE1BQU1lLEtBQUssRUFBRWQsR0FBR0ssR0FBRyxDQUFDLFNBQVNOLE1BQU1lLEtBQUs7UUFDNUMsS0FBSWYscUJBQUFBLE1BQU1nQixXQUFXLGNBQWpCaEIseUNBQUFBLG1CQUFtQmlCLE1BQU0sRUFBRWhCLEdBQUdLLEdBQUcsQ0FBQyxV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UUFBUW9CLE9BQU9wQixNQUFNLEdBQUdBO1FBQzVCLElBQUlDLFFBQVFtQixPQUFPbkIsTUFBTSxHQUFHQTtRQUM1QixJQUFJQyxNQUFNa0IsT0FBT2xCLElBQUksR0FBR0E7UUFDeEIsSUFBSW1CLE9BQU9DLElBQUksQ0FBQ0YsUUFBUUosTUFBTSxHQUFHLEdBQUdqQyxNQUFNZ0IsV0FBVyxHQUFHcUI7SUFDMUQ7SUFFQSxPQUFPckM7QUFDVDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVN3QyxjQUFjQyxPQUFlLEVBQUV6QyxLQUFjO0lBQzNELE1BQU0wQyxJQUFJM0MsbUJBQW1CQztJQUM3QixNQUFNMkMsVUFBVUYsUUFBUUcsUUFBUSxDQUFDLE9BQU9ILFFBQVFJLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEUsTUFBTSxDQUFDQyxZQUFZQyxLQUFLLEdBQUdKLFdBQVcsSUFBSTtRQUFDRixRQUFRaEIsS0FBSyxDQUFDLEdBQUdrQjtRQUFVRixRQUFRaEIsS0FBSyxDQUFDa0I7S0FBUyxHQUFHO1FBQUNGO1FBQVM7S0FBRztJQUM3RyxNQUFNTyxjQUFjRixXQUFXRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDNUMsTUFBTUMsTUFBTUYsWUFBWUosUUFBUSxDQUFDLE9BQU8sS0FBSztJQUM3QyxPQUFPLEdBQWlCTSxPQUFkRixhQUFvQk4sT0FBTlEsS0FBVUgsT0FBSkwsR0FBUyxPQUFMSztBQUNwQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BhdC9Qcm9qZWN0cy9wcm9tcHQtdG8tdWkvYXBwcy9kZW1vL2FwcC91dGlscy91cmxTdGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQdXJlIGhlbHBlcnMgZm9yIGVuY29kaW5nL2RlY29kaW5nIFBsYXlncm91bmQgVUkgc3RhdGUgaW50byBVUkwgcXVlcnkgc3RyaW5ncy5cbi8vIE5vIE5leHQuanMgb3IgRE9NIEFQSXMgdXNlZCwgc2FmZSBmb3IgdW5pdCB0ZXN0aW5nLlxuXG5leHBvcnQgdHlwZSBUaGVtZU5hbWUgPSAnbWluaW1hbCcgfCAncGxheWZ1bCcgfCAnZWxlZ2FudCcgfCAnY3liZXInXG5leHBvcnQgdHlwZSBGb250VG9rZW4gPSAnc3lzdGVtJyB8ICdpbnRlcicgfCAnc2VyaWYnXG5leHBvcnQgdHlwZSBWYXJpYXRpb25TdHJhdGVneSA9ICdub25lJyB8ICdyZXZlcnNlLWZlYXR1cmVzJyB8ICdzaHVmZmxlLXByaWNpbmcnIHwgJ2JvdGgnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGhlbWVUb2tlbnMge1xuICBhY2NlbnQ/OiBzdHJpbmcgLy8gaGV4IGNvbG9yIGxpa2UgIzFlOTBmZlxuICByYWRpdXM/OiBzdHJpbmcgLy8gZS5nLiBcIjEwcHhcIlxuICBmb250PzogRm9udFRva2VuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVUlTdGF0ZSB7XG4gIHByb21wdD86IHN0cmluZ1xuICBzZWVkPzogbnVtYmVyXG4gIHRoZW1lPzogVGhlbWVOYW1lXG4gIHRoZW1lVG9rZW5zPzogVGhlbWVUb2tlbnNcbiAgYXV0b1N0eWxlPzogYm9vbGVhblxuICBzdHlsZU1vZGU/OiAnYXV0bycgfCAnZXhwbGljaXQnIHwgJ3NlZWRlZCdcbiAgdmFyaWF0aW9uU3RyYXRlZ3k/OiBWYXJpYXRpb25TdHJhdGVneVxufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMU2VhcmNoUGFyYW1zIGZyb20gVUlTdGF0ZS5cbiAqIE5vdGVzOlxuICogLSBJZiBhdXRvU3R5bGUgaXMgdHJ1ZSwgdGhlbWUgYW5kIHRoZW1lVG9rZW5zIGFyZSBvbWl0dGVkIChiYWNrZW5kIGluZmVycyBzdHlsZSBmcm9tIHByb21wdCkuXG4gKiAtIFVuZGVmaW5lZC9lbXB0eSB2YWx1ZXMgYXJlIG9taXR0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVTdGF0ZVRvUXVlcnkoc3RhdGU6IFVJU3RhdGUpOiBzdHJpbmcge1xuICBjb25zdCBzcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuXG4gIGNvbnN0IHRyaW1tZWRQcm9tcHQgPSBzdGF0ZS5wcm9tcHQ/LnRyaW0oKVxuICBpZiAodHJpbW1lZFByb21wdCkgc3Auc2V0KCdwcm9tcHQnLCB0cmltbWVkUHJvbXB0KVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuc2VlZCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXRlLnNlZWQpKSB7XG4gICAgc3Auc2V0KCdzZWVkJywgU3RyaW5nKHN0YXRlLnNlZWQpKVxuICB9XG5cbiAgY29uc3QgbW9kZSA9IHN0YXRlLnN0eWxlTW9kZSA/PyAoc3RhdGUuYXV0b1N0eWxlID8gJ2F1dG8nIDogJ2V4cGxpY2l0JylcbiAgY29uc3QgYXV0byA9IG1vZGUgPT09ICdhdXRvJ1xuICBpZiAoYXV0bykge1xuICAgIHNwLnNldCgnYXV0b1N0eWxlJywgJzEnKVxuICAgIHNwLnNldCgnc3R5bGVNb2RlJywgJ2F1dG8nKVxuICB9IGVsc2UgaWYgKHN0YXRlLmF1dG9TdHlsZSA9PT0gZmFsc2UpIHtcbiAgICBzcC5zZXQoJ2F1dG9TdHlsZScsICcwJylcbiAgICBzcC5zZXQoJ3N0eWxlTW9kZScsIG1vZGUpXG4gIH1cblxuICAvLyBPbmx5IGluY2x1ZGUgdGhlbWUvdG9rZW5zIHdoZW4gbm90IGluIGF1dG8gc3R5bGUgbW9kZVxuICBpZiAoIWF1dG8gJiYgbW9kZSAhPT0gJ3NlZWRlZCcpIHtcbiAgICBpZiAoc3RhdGUudGhlbWUpIHNwLnNldCgndGhlbWUnLCBzdGF0ZS50aGVtZSlcbiAgICBpZiAoc3RhdGUudGhlbWVUb2tlbnM/LmFjY2VudCkgc3Auc2V0KCdhY2NlbnQnLCBzdGF0ZS50aGVtZVRva2Vucy5hY2NlbnQpXG4gICAgaWYgKHN0YXRlLnRoZW1lVG9rZW5zPy5yYWRpdXMpIHNwLnNldCgncmFkaXVzJywgc3RhdGUudGhlbWVUb2tlbnMucmFkaXVzKVxuICAgIGlmIChzdGF0ZS50aGVtZVRva2Vucz8uZm9udCkgc3Auc2V0KCdmb250Jywgc3RhdGUudGhlbWVUb2tlbnMuZm9udClcbiAgfVxuXG4gIGlmIChzdGF0ZS52YXJpYXRpb25TdHJhdGVneSkge1xuICAgIHNwLnNldCgndmFyaWF0aW9uU3RyYXRlZ3knLCBzdGF0ZS52YXJpYXRpb25TdHJhdGVneSlcbiAgfVxuXG4gIC8vIFJldHVybiB3aXRob3V0IGxlYWRpbmcgXCI/XCJcbiAgcmV0dXJuIHNwLnRvU3RyaW5nKClcbn1cblxuLyoqXG4gKiBQYXJzZSBxdWVyeSBzdHJpbmcgb3IgVVJMU2VhcmNoUGFyYW1zIGludG8gVUlTdGF0ZS5cbiAqIC0gQWNjZXB0cyBib29sZWFucyBhcyAnMScvJzAnIG9yICd0cnVlJy8nZmFsc2UnIChjYXNlLWluc2Vuc2l0aXZlKS5cbiAqIC0gQ29lcmNlcyBzZWVkIHRvIG51bWJlciBpZiBmaW5pdGU7IG90aGVyd2lzZSB1bmRlZmluZWQuXG4gKiAtIElmIGF1dG9TdHlsZSByZXNvbHZlcyB0byB0cnVlLCB0aGVtZSBhbmQgdGhlbWVUb2tlbnMgd2lsbCBiZSBkcm9wcGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VRdWVyeVRvU3RhdGUocXM6IHN0cmluZyB8IFVSTFNlYXJjaFBhcmFtcyk6IFVJU3RhdGUge1xuICBjb25zdCBzcCA9IHR5cGVvZiBxcyA9PT0gJ3N0cmluZycgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzLnN0YXJ0c1dpdGgoJz8nKSA/IHFzLnNsaWNlKDEpIDogcXMpIDogcXNcblxuICBjb25zdCBnZXRCb29sID0gKGtleTogc3RyaW5nKTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFzcC5oYXMoa2V5KSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGNvbnN0IHYgPSBzcC5nZXQoa2V5KT8udG9Mb3dlckNhc2UoKVxuICAgIGlmICh2ID09PSAnMScgfHwgdiA9PT0gJ3RydWUnKSByZXR1cm4gdHJ1ZVxuICAgIGlmICh2ID09PSAnMCcgfHwgdiA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3Qgc3RhdGU6IFVJU3RhdGUgPSB7fVxuXG4gIGNvbnN0IHByb21wdCA9IHNwLmdldCgncHJvbXB0JykgPz8gdW5kZWZpbmVkXG4gIGlmIChwcm9tcHQgJiYgcHJvbXB0LnRyaW0oKS5sZW5ndGggPiAwKSBzdGF0ZS5wcm9tcHQgPSBwcm9tcHRcblxuICBjb25zdCBzZWVkUmF3ID0gc3AuZ2V0KCdzZWVkJylcbiAgaWYgKHNlZWRSYXcgIT0gbnVsbCAmJiBzZWVkUmF3ICE9PSAnJykge1xuICAgIGNvbnN0IG4gPSBOdW1iZXIoc2VlZFJhdylcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG4pKSBzdGF0ZS5zZWVkID0gblxuICB9XG5cbiAgY29uc3QgYXV0b1N0eWxlID0gZ2V0Qm9vbCgnYXV0b1N0eWxlJylcbiAgaWYgKHR5cGVvZiBhdXRvU3R5bGUgIT09ICd1bmRlZmluZWQnKSBzdGF0ZS5hdXRvU3R5bGUgPSBhdXRvU3R5bGVcblxuICBjb25zdCBzdHlsZU1vZGUgPSAoc3AuZ2V0KCdzdHlsZU1vZGUnKSBhcyAnYXV0bycgfCAnZXhwbGljaXQnIHwgJ3NlZWRlZCcgfCBudWxsKSB8fCBudWxsXG4gIGlmIChzdHlsZU1vZGUpIHN0YXRlLnN0eWxlTW9kZSA9IHN0eWxlTW9kZVxuICBpZiAoIXN0eWxlTW9kZSAmJiB0eXBlb2Ygc3RhdGUuYXV0b1N0eWxlID09PSAnYm9vbGVhbicpIHtcbiAgICBzdGF0ZS5zdHlsZU1vZGUgPSBzdGF0ZS5hdXRvU3R5bGUgPyAnYXV0bycgOiAnZXhwbGljaXQnXG4gIH1cblxuICBjb25zdCB0aGVtZSA9IHNwLmdldCgndGhlbWUnKSBhcyBUaGVtZU5hbWUgfCBudWxsXG4gIGNvbnN0IGFjY2VudCA9IHNwLmdldCgnYWNjZW50JykgPz8gdW5kZWZpbmVkXG4gIGNvbnN0IHJhZGl1cyA9IHNwLmdldCgncmFkaXVzJykgPz8gdW5kZWZpbmVkXG4gIGNvbnN0IGZvbnQgPSBzcC5nZXQoJ2ZvbnQnKSBhcyBGb250VG9rZW4gfCBudWxsXG5cbiAgY29uc3QgdmFyaWF0aW9uU3RyYXRlZ3kgPSBzcC5nZXQoJ3ZhcmlhdGlvblN0cmF0ZWd5JykgYXMgVmFyaWF0aW9uU3RyYXRlZ3kgfCBudWxsXG4gIGlmICh2YXJpYXRpb25TdHJhdGVneSkgc3RhdGUudmFyaWF0aW9uU3RyYXRlZ3kgPSB2YXJpYXRpb25TdHJhdGVneVxuXG4gIC8vIElmIGF1dG9TdHlsZT10cnVlIE9SIHN0eWxlTW9kZT1zZWVkZWQsIGlnbm9yZSBleHBsaWNpdCB0aGVtZS90b2tlbnMgKGZyb250ZW5kIHdpbGwgZGVyaXZlKVxuICBjb25zdCBhbGxvd0V4cGxpY2l0ID0gIShhdXRvU3R5bGUgPT09IHRydWUgfHwgc3R5bGVNb2RlID09PSAnc2VlZGVkJylcblxuICBpZiAoYWxsb3dFeHBsaWNpdCkge1xuICAgIGlmICh0aGVtZSkgc3RhdGUudGhlbWUgPSB0aGVtZVxuICAgIGNvbnN0IHRva2VuczogVGhlbWVUb2tlbnMgPSB7fVxuICAgIGlmIChhY2NlbnQpIHRva2Vucy5hY2NlbnQgPSBhY2NlbnRcbiAgICBpZiAocmFkaXVzKSB0b2tlbnMucmFkaXVzID0gcmFkaXVzXG4gICAgaWYgKGZvbnQpIHRva2Vucy5mb250ID0gZm9udFxuICAgIGlmIChPYmplY3Qua2V5cyh0b2tlbnMpLmxlbmd0aCA+IDApIHN0YXRlLnRoZW1lVG9rZW5zID0gdG9rZW5zXG4gIH1cblxuICByZXR1cm4gc3RhdGVcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bGwgc2hhcmVhYmxlIFVSTCBieSBhcHBlbmRpbmcgdGhlIGVuY29kZWQgcXVlcnkgdG8gYSBiYXNlIFVSTC5cbiAqIElmIGJhc2UgYWxyZWFkeSBoYXMgYSBxdWVyeSwgaXQgd2lsbCBiZSByZXBsYWNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2hhcmVVUkwoYmFzZVVybDogc3RyaW5nLCBzdGF0ZTogVUlTdGF0ZSk6IHN0cmluZyB7XG4gIGNvbnN0IHEgPSBlbmNvZGVTdGF0ZVRvUXVlcnkoc3RhdGUpXG4gIGNvbnN0IGhhc0hhc2ggPSBiYXNlVXJsLmluY2x1ZGVzKCcjJykgPyBiYXNlVXJsLmluZGV4T2YoJyMnKSA6IC0xXG4gIGNvbnN0IFtiZWZvcmVIYXNoLCBoYXNoXSA9IGhhc0hhc2ggPj0gMCA/IFtiYXNlVXJsLnNsaWNlKDAsIGhhc0hhc2gpLCBiYXNlVXJsLnNsaWNlKGhhc0hhc2gpXSA6IFtiYXNlVXJsLCAnJ11cbiAgY29uc3QgYmFzZU5vUXVlcnkgPSBiZWZvcmVIYXNoLnNwbGl0KCc/JylbMF1cbiAgY29uc3Qgc2VwID0gYmFzZU5vUXVlcnkuaW5jbHVkZXMoJz8nKSA/ICcnIDogJz8nXG4gIHJldHVybiBgJHtiYXNlTm9RdWVyeX0ke3NlcH0ke3F9JHtoYXNofWBcbn1cbiJdLCJuYW1lcyI6WyJlbmNvZGVTdGF0ZVRvUXVlcnkiLCJzdGF0ZSIsInNwIiwiVVJMU2VhcmNoUGFyYW1zIiwidHJpbW1lZFByb21wdCIsInByb21wdCIsInRyaW0iLCJzZXQiLCJzZWVkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJTdHJpbmciLCJtb2RlIiwic3R5bGVNb2RlIiwiYXV0b1N0eWxlIiwiYXV0byIsInRoZW1lIiwidGhlbWVUb2tlbnMiLCJhY2NlbnQiLCJyYWRpdXMiLCJmb250IiwidmFyaWF0aW9uU3RyYXRlZ3kiLCJ0b1N0cmluZyIsInBhcnNlUXVlcnlUb1N0YXRlIiwicXMiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJnZXRCb29sIiwia2V5IiwiaGFzIiwidW5kZWZpbmVkIiwidiIsImdldCIsInRvTG93ZXJDYXNlIiwibGVuZ3RoIiwic2VlZFJhdyIsIm4iLCJhbGxvd0V4cGxpY2l0IiwidG9rZW5zIiwiT2JqZWN0Iiwia2V5cyIsImJ1aWxkU2hhcmVVUkwiLCJiYXNlVXJsIiwicSIsImhhc0hhc2giLCJpbmNsdWRlcyIsImluZGV4T2YiLCJiZWZvcmVIYXNoIiwiaGFzaCIsImJhc2VOb1F1ZXJ5Iiwic3BsaXQiLCJzZXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/urlState.ts\n"));

/***/ })

});