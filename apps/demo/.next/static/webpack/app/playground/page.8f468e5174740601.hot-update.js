"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/playground/page",{

/***/ "(app-pages-browser)/./app/utils/urlState.ts":
/*!*******************************!*\
  !*** ./app/utils/urlState.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildShareURL: () => (/* binding */ buildShareURL),\n/* harmony export */   encodeStateToQuery: () => (/* binding */ encodeStateToQuery),\n/* harmony export */   parseQueryToState: () => (/* binding */ parseQueryToState)\n/* harmony export */ });\n// Pure helpers for encoding/decoding Playground UI state into URL query strings.\n// No Next.js or DOM APIs used, safe for unit testing.\n/**\n * Build a URLSearchParams from UIState.\n * Notes:\n * - If autoStyle is true, theme and themeTokens are omitted (backend infers style from prompt).\n * - Undefined/empty values are omitted.\n */ function encodeStateToQuery(state) {\n    var _state_prompt;\n    const sp = new URLSearchParams();\n    const trimmedPrompt = (_state_prompt = state.prompt) === null || _state_prompt === void 0 ? void 0 : _state_prompt.trim();\n    if (trimmedPrompt) sp.set('prompt', trimmedPrompt);\n    if (typeof state.seed === 'number' && Number.isFinite(state.seed)) {\n        sp.set('seed', String(state.seed));\n    }\n    var _state_styleMode;\n    const mode = (_state_styleMode = state.styleMode) !== null && _state_styleMode !== void 0 ? _state_styleMode : state.autoStyle ? 'auto' : 'explicit';\n    const auto = mode === 'auto';\n    // Always include styleMode when known\n    if (mode) sp.set('styleMode', mode);\n    // Keep autoStyle flag for backward compatibility and server parsing\n    if (auto) {\n        sp.set('autoStyle', '1');\n    } else if (mode) {\n        sp.set('autoStyle', '0');\n    } else if (state.autoStyle === false) {\n        sp.set('autoStyle', '0');\n    }\n    // Only include theme/tokens when not in auto style mode\n    if (!auto && mode !== 'seeded') {\n        var _state_themeTokens, _state_themeTokens1, _state_themeTokens2;\n        if (state.theme) sp.set('theme', state.theme);\n        if ((_state_themeTokens = state.themeTokens) === null || _state_themeTokens === void 0 ? void 0 : _state_themeTokens.accent) sp.set('accent', state.themeTokens.accent);\n        if ((_state_themeTokens1 = state.themeTokens) === null || _state_themeTokens1 === void 0 ? void 0 : _state_themeTokens1.radius) sp.set('radius', state.themeTokens.radius);\n        if ((_state_themeTokens2 = state.themeTokens) === null || _state_themeTokens2 === void 0 ? void 0 : _state_themeTokens2.font) sp.set('font', state.themeTokens.font);\n    }\n    if (state.variationStrategy) {\n        sp.set('variationStrategy', state.variationStrategy);\n    }\n    // Return without leading \"?\"\n    return sp.toString();\n}\n/**\n * Parse query string or URLSearchParams into UIState.\n * - Accepts booleans as '1'/'0' or 'true'/'false' (case-insensitive).\n * - Coerces seed to number if finite; otherwise undefined.\n * - If autoStyle resolves to true, theme and themeTokens will be dropped.\n */ function parseQueryToState(qs) {\n    const sp = typeof qs === 'string' ? new URLSearchParams(qs.startsWith('?') ? qs.slice(1) : qs) : qs;\n    const getBool = (key)=>{\n        var _sp_get;\n        if (!sp.has(key)) return undefined;\n        const v = (_sp_get = sp.get(key)) === null || _sp_get === void 0 ? void 0 : _sp_get.toLowerCase();\n        if (v === '1' || v === 'true') return true;\n        if (v === '0' || v === 'false') return false;\n        return undefined;\n    };\n    const state = {};\n    var _sp_get;\n    const prompt = (_sp_get = sp.get('prompt')) !== null && _sp_get !== void 0 ? _sp_get : undefined;\n    if (prompt && prompt.trim().length > 0) state.prompt = prompt;\n    const seedRaw = sp.get('seed');\n    if (seedRaw != null && seedRaw !== '') {\n        const n = Number(seedRaw);\n        if (Number.isFinite(n)) state.seed = n;\n    }\n    const autoStyle = getBool('autoStyle');\n    if (typeof autoStyle !== 'undefined') state.autoStyle = autoStyle;\n    const styleMode = sp.get('styleMode') || null;\n    if (styleMode) state.styleMode = styleMode;\n    if (!styleMode && typeof state.autoStyle === 'boolean') {\n        state.styleMode = state.autoStyle ? 'auto' : 'explicit';\n    }\n    const theme = sp.get('theme');\n    var _sp_get1;\n    const accent = (_sp_get1 = sp.get('accent')) !== null && _sp_get1 !== void 0 ? _sp_get1 : undefined;\n    var _sp_get2;\n    const radius = (_sp_get2 = sp.get('radius')) !== null && _sp_get2 !== void 0 ? _sp_get2 : undefined;\n    const font = sp.get('font');\n    const variationStrategy = sp.get('variationStrategy');\n    if (variationStrategy) state.variationStrategy = variationStrategy;\n    // If autoStyle=true OR styleMode=seeded, ignore explicit theme/tokens (frontend will derive)\n    const allowExplicit = !(autoStyle === true || styleMode === 'seeded');\n    if (allowExplicit) {\n        if (theme) state.theme = theme;\n        const tokens = {};\n        if (accent) tokens.accent = accent;\n        if (radius) tokens.radius = radius;\n        if (font) tokens.font = font;\n        if (Object.keys(tokens).length > 0) state.themeTokens = tokens;\n    }\n    return state;\n}\n/**\n * Build a full shareable URL by appending the encoded query to a base URL.\n * If base already has a query, it will be replaced.\n */ function buildShareURL(baseUrl, state) {\n    const q = encodeStateToQuery(state);\n    const hasHash = baseUrl.includes('#') ? baseUrl.indexOf('#') : -1;\n    const [beforeHash, hash] = hasHash >= 0 ? [\n        baseUrl.slice(0, hasHash),\n        baseUrl.slice(hasHash)\n    ] : [\n        baseUrl,\n        ''\n    ];\n    const baseNoQuery = beforeHash.split('?')[0];\n    const sep = baseNoQuery.includes('?') ? '' : '?';\n    return \"\".concat(baseNoQuery).concat(sep).concat(q).concat(hash);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy91cmxTdGF0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpRkFBaUY7QUFDakYsc0RBQXNEO0FBc0J0RDs7Ozs7Q0FLQyxHQUNNLFNBQVNBLG1CQUFtQkMsS0FBYztRQUd6QkE7SUFGdEIsTUFBTUMsS0FBSyxJQUFJQztJQUVmLE1BQU1DLGlCQUFnQkgsZ0JBQUFBLE1BQU1JLE1BQU0sY0FBWkosb0NBQUFBLGNBQWNLLElBQUk7SUFDeEMsSUFBSUYsZUFBZUYsR0FBR0ssR0FBRyxDQUFDLFVBQVVIO0lBRXBDLElBQUksT0FBT0gsTUFBTU8sSUFBSSxLQUFLLFlBQVlDLE9BQU9DLFFBQVEsQ0FBQ1QsTUFBTU8sSUFBSSxHQUFHO1FBQ2pFTixHQUFHSyxHQUFHLENBQUMsUUFBUUksT0FBT1YsTUFBTU8sSUFBSTtJQUNsQztRQUVhUDtJQUFiLE1BQU1XLE9BQU9YLENBQUFBLG1CQUFBQSxNQUFNWSxTQUFTLGNBQWZaLDhCQUFBQSxtQkFBb0JBLE1BQU1hLFNBQVMsR0FBRyxTQUFTO0lBQzVELE1BQU1DLE9BQU9ILFNBQVM7SUFDdEIsc0NBQXNDO0lBQ3RDLElBQUlBLE1BQU1WLEdBQUdLLEdBQUcsQ0FBQyxhQUFhSztJQUM5QixvRUFBb0U7SUFDcEUsSUFBSUcsTUFBTTtRQUNSYixHQUFHSyxHQUFHLENBQUMsYUFBYTtJQUN0QixPQUFPLElBQUlLLE1BQU07UUFDZlYsR0FBR0ssR0FBRyxDQUFDLGFBQWE7SUFDdEIsT0FBTyxJQUFJTixNQUFNYSxTQUFTLEtBQUssT0FBTztRQUNwQ1osR0FBR0ssR0FBRyxDQUFDLGFBQWE7SUFDdEI7SUFFQSx3REFBd0Q7SUFDeEQsSUFBSSxDQUFDUSxRQUFRSCxTQUFTLFVBQVU7WUFFMUJYLG9CQUNBQSxxQkFDQUE7UUFISixJQUFJQSxNQUFNZSxLQUFLLEVBQUVkLEdBQUdLLEdBQUcsQ0FBQyxTQUFTTixNQUFNZSxLQUFLO1FBQzVDLEtBQUlmLHFCQUFBQSxNQUFNZ0Is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QU9mLE1BQU1lLEtBQUssR0FBR0E7UUFDekIsTUFBTXNCLFNBQXNCLENBQUM7UUFDN0IsSUFBSXBCLFFBQVFvQixPQUFPcEIsTUFBTSxHQUFHQTtRQUM1QixJQUFJQyxRQUFRbUIsT0FBT25CLE1BQU0sR0FBR0E7UUFDNUIsSUFBSUMsTUFBTWtCLE9BQU9sQixJQUFJLEdBQUdBO1FBQ3hCLElBQUltQixPQUFPQyxJQUFJLENBQUNGLFFBQVFKLE1BQU0sR0FBRyxHQUFHakMsTUFBTWdCLFdBQVcsR0FBR3FCO0lBQzFEO0lBRUEsT0FBT3JDO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDTSxTQUFTd0MsY0FBY0MsT0FBZSxFQUFFekMsS0FBYztJQUMzRCxNQUFNMEMsSUFBSTNDLG1CQUFtQkM7SUFDN0IsTUFBTTJDLFVBQVVGLFFBQVFHLFFBQVEsQ0FBQyxPQUFPSCxRQUFRSSxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hFLE1BQU0sQ0FBQ0MsWUFBWUMsS0FBSyxHQUFHSixXQUFXLElBQUk7UUFBQ0YsUUFBUWhCLEtBQUssQ0FBQyxHQUFHa0I7UUFBVUYsUUFBUWhCLEtBQUssQ0FBQ2tCO0tBQVMsR0FBRztRQUFDRjtRQUFTO0tBQUc7SUFDN0csTUFBTU8sY0FBY0YsV0FBV0csS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQzVDLE1BQU1DLE1BQU1GLFlBQVlKLFFBQVEsQ0FBQyxPQUFPLEtBQUs7SUFDN0MsT0FBTyxHQUFpQk0sT0FBZEYsYUFBb0JOLE9BQU5RLEtBQVVILE9BQUpMLEdBQVMsT0FBTEs7QUFDcEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXQvUHJvamVjdHMvcHJvbXB0LXRvLXVpL2FwcHMvZGVtby9hcHAvdXRpbHMvdXJsU3RhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHVyZSBoZWxwZXJzIGZvciBlbmNvZGluZy9kZWNvZGluZyBQbGF5Z3JvdW5kIFVJIHN0YXRlIGludG8gVVJMIHF1ZXJ5IHN0cmluZ3MuXG4vLyBObyBOZXh0LmpzIG9yIERPTSBBUElzIHVzZWQsIHNhZmUgZm9yIHVuaXQgdGVzdGluZy5cblxuZXhwb3J0IHR5cGUgVGhlbWVOYW1lID0gJ21pbmltYWwnIHwgJ3BsYXlmdWwnIHwgJ2VsZWdhbnQnIHwgJ2N5YmVyJ1xuZXhwb3J0IHR5cGUgRm9udFRva2VuID0gJ3N5c3RlbScgfCAnaW50ZXInIHwgJ3NlcmlmJ1xuZXhwb3J0IHR5cGUgVmFyaWF0aW9uU3RyYXRlZ3kgPSAnbm9uZScgfCAncmV2ZXJzZS1mZWF0dXJlcycgfCAnc2h1ZmZsZS1wcmljaW5nJyB8ICdib3RoJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRoZW1lVG9rZW5zIHtcbiAgYWNjZW50Pzogc3RyaW5nIC8vIGhleCBjb2xvciBsaWtlICMxZTkwZmZcbiAgcmFkaXVzPzogc3RyaW5nIC8vIGUuZy4gXCIxMHB4XCJcbiAgZm9udD86IEZvbnRUb2tlblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVJU3RhdGUge1xuICBwcm9tcHQ/OiBzdHJpbmdcbiAgc2VlZD86IG51bWJlclxuICB0aGVtZT86IFRoZW1lTmFtZVxuICB0aGVtZVRva2Vucz86IFRoZW1lVG9rZW5zXG4gIGF1dG9TdHlsZT86IGJvb2xlYW5cbiAgc3R5bGVNb2RlPzogJ2F1dG8nIHwgJ2V4cGxpY2l0JyB8ICdzZWVkZWQnXG4gIHZhcmlhdGlvblN0cmF0ZWd5PzogVmFyaWF0aW9uU3RyYXRlZ3lcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTFNlYXJjaFBhcmFtcyBmcm9tIFVJU3RhdGUuXG4gKiBOb3RlczpcbiAqIC0gSWYgYXV0b1N0eWxlIGlzIHRydWUsIHRoZW1lIGFuZCB0aGVtZVRva2VucyBhcmUgb21pdHRlZCAoYmFja2VuZCBpbmZlcnMgc3R5bGUgZnJvbSBwcm9tcHQpLlxuICogLSBVbmRlZmluZWQvZW1wdHkgdmFsdWVzIGFyZSBvbWl0dGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU3RhdGVUb1F1ZXJ5KHN0YXRlOiBVSVN0YXRlKTogc3RyaW5nIHtcbiAgY29uc3Qgc3AgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcblxuICBjb25zdCB0cmltbWVkUHJvbXB0ID0gc3RhdGUucHJvbXB0Py50cmltKClcbiAgaWYgKHRyaW1tZWRQcm9tcHQpIHNwLnNldCgncHJvbXB0JywgdHJpbW1lZFByb21wdClcblxuICBpZiAodHlwZW9mIHN0YXRlLnNlZWQgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShzdGF0ZS5zZWVkKSkge1xuICAgIHNwLnNldCgnc2VlZCcsIFN0cmluZyhzdGF0ZS5zZWVkKSlcbiAgfVxuXG4gIGNvbnN0IG1vZGUgPSBzdGF0ZS5zdHlsZU1vZGUgPz8gKHN0YXRlLmF1dG9TdHlsZSA/ICdhdXRvJyA6ICdleHBsaWNpdCcpXG4gIGNvbnN0IGF1dG8gPSBtb2RlID09PSAnYXV0bydcbiAgLy8gQWx3YXlzIGluY2x1ZGUgc3R5bGVNb2RlIHdoZW4ga25vd25cbiAgaWYgKG1vZGUpIHNwLnNldCgnc3R5bGVNb2RlJywgbW9kZSlcbiAgLy8gS2VlcCBhdXRvU3R5bGUgZmxhZyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhbmQgc2VydmVyIHBhcnNpbmdcbiAgaWYgKGF1dG8pIHtcbiAgICBzcC5zZXQoJ2F1dG9TdHlsZScsICcxJylcbiAgfSBlbHNlIGlmIChtb2RlKSB7XG4gICAgc3Auc2V0KCdhdXRvU3R5bGUnLCAnMCcpXG4gIH0gZWxzZSBpZiAoc3RhdGUuYXV0b1N0eWxlID09PSBmYWxzZSkge1xuICAgIHNwLnNldCgnYXV0b1N0eWxlJywgJzAnKVxuICB9XG5cbiAgLy8gT25seSBpbmNsdWRlIHRoZW1lL3Rva2VucyB3aGVuIG5vdCBpbiBhdXRvIHN0eWxlIG1vZGVcbiAgaWYgKCFhdXRvICYmIG1vZGUgIT09ICdzZWVkZWQnKSB7XG4gICAgaWYgKHN0YXRlLnRoZW1lKSBzcC5zZXQoJ3RoZW1lJywgc3RhdGUudGhlbWUpXG4gICAgaWYgKHN0YXRlLnRoZW1lVG9rZW5zPy5hY2NlbnQpIHNwLnNldCgnYWNjZW50Jywgc3RhdGUudGhlbWVUb2tlbnMuYWNjZW50KVxuICAgIGlmIChzdGF0ZS50aGVtZVRva2Vucz8ucmFkaXVzKSBzcC5zZXQoJ3JhZGl1cycsIHN0YXRlLnRoZW1lVG9rZW5zLnJhZGl1cylcbiAgICBpZiAoc3RhdGUudGhlbWVUb2tlbnM/LmZvbnQpIHNwLnNldCgnZm9udCcsIHN0YXRlLnRoZW1lVG9rZW5zLmZvbnQpXG4gIH1cblxuICBpZiAoc3RhdGUudmFyaWF0aW9uU3RyYXRlZ3kpIHtcbiAgICBzcC5zZXQoJ3ZhcmlhdGlvblN0cmF0ZWd5Jywgc3RhdGUudmFyaWF0aW9uU3RyYXRlZ3kpXG4gIH1cblxuICAvLyBSZXR1cm4gd2l0aG91dCBsZWFkaW5nIFwiP1wiXG4gIHJldHVybiBzcC50b1N0cmluZygpXG59XG5cbi8qKlxuICogUGFyc2UgcXVlcnkgc3RyaW5nIG9yIFVSTFNlYXJjaFBhcmFtcyBpbnRvIFVJU3RhdGUuXG4gKiAtIEFjY2VwdHMgYm9vbGVhbnMgYXMgJzEnLycwJyBvciAndHJ1ZScvJ2ZhbHNlJyAoY2FzZS1pbnNlbnNpdGl2ZSkuXG4gKiAtIENvZXJjZXMgc2VlZCB0byBudW1iZXIgaWYgZmluaXRlOyBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICogLSBJZiBhdXRvU3R5bGUgcmVzb2x2ZXMgdG8gdHJ1ZSwgdGhlbWUgYW5kIHRoZW1lVG9rZW5zIHdpbGwgYmUgZHJvcHBlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUXVlcnlUb1N0YXRlKHFzOiBzdHJpbmcgfCBVUkxTZWFyY2hQYXJhbXMpOiBVSVN0YXRlIHtcbiAgY29uc3Qgc3AgPSB0eXBlb2YgcXMgPT09ICdzdHJpbmcnID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhxcy5zdGFydHNXaXRoKCc/JykgPyBxcy5zbGljZSgxKSA6IHFzKSA6IHFzXG5cbiAgY29uc3QgZ2V0Qm9vbCA9IChrZXk6IHN0cmluZyk6IGJvb2xlYW4gfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmICghc3AuaGFzKGtleSkpIHJldHVybiB1bmRlZmluZWRcbiAgICBjb25zdCB2ID0gc3AuZ2V0KGtleSk/LnRvTG93ZXJDYXNlKClcbiAgICBpZiAodiA9PT0gJzEnIHx8IHYgPT09ICd0cnVlJykgcmV0dXJuIHRydWVcbiAgICBpZiAodiA9PT0gJzAnIHx8IHYgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IHN0YXRlOiBVSVN0YXRlID0ge31cblxuICBjb25zdCBwcm9tcHQgPSBzcC5nZXQoJ3Byb21wdCcpID8/IHVuZGVmaW5lZFxuICBpZiAocHJvbXB0ICYmIHByb21wdC50cmltKCkubGVuZ3RoID4gMCkgc3RhdGUucHJvbXB0ID0gcHJvbXB0XG5cbiAgY29uc3Qgc2VlZFJhdyA9IHNwLmdldCgnc2VlZCcpXG4gIGlmIChzZWVkUmF3ICE9IG51bGwgJiYgc2VlZFJhdyAhPT0gJycpIHtcbiAgICBjb25zdCBuID0gTnVtYmVyKHNlZWRSYXcpXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShuKSkgc3RhdGUuc2VlZCA9IG5cbiAgfVxuXG4gIGNvbnN0IGF1dG9TdHlsZSA9IGdldEJvb2woJ2F1dG9TdHlsZScpXG4gIGlmICh0eXBlb2YgYXV0b1N0eWxlICE9PSAndW5kZWZpbmVkJykgc3RhdGUuYXV0b1N0eWxlID0gYXV0b1N0eWxlXG5cbiAgY29uc3Qgc3R5bGVNb2RlID0gKHNwLmdldCgnc3R5bGVNb2RlJykgYXMgJ2F1dG8nIHwgJ2V4cGxpY2l0JyB8ICdzZWVkZWQnIHwgbnVsbCkgfHwgbnVsbFxuICBpZiAoc3R5bGVNb2RlKSBzdGF0ZS5zdHlsZU1vZGUgPSBzdHlsZU1vZGVcbiAgaWYgKCFzdHlsZU1vZGUgJiYgdHlwZW9mIHN0YXRlLmF1dG9TdHlsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc3RhdGUuc3R5bGVNb2RlID0gc3RhdGUuYXV0b1N0eWxlID8gJ2F1dG8nIDogJ2V4cGxpY2l0J1xuICB9XG5cbiAgY29uc3QgdGhlbWUgPSBzcC5nZXQoJ3RoZW1lJykgYXMgVGhlbWVOYW1lIHwgbnVsbFxuICBjb25zdCBhY2NlbnQgPSBzcC5nZXQoJ2FjY2VudCcpID8/IHVuZGVmaW5lZFxuICBjb25zdCByYWRpdXMgPSBzcC5nZXQoJ3JhZGl1cycpID8/IHVuZGVmaW5lZFxuICBjb25zdCBmb250ID0gc3AuZ2V0KCdmb250JykgYXMgRm9udFRva2VuIHwgbnVsbFxuXG4gIGNvbnN0IHZhcmlhdGlvblN0cmF0ZWd5ID0gc3AuZ2V0KCd2YXJpYXRpb25TdHJhdGVneScpIGFzIFZhcmlhdGlvblN0cmF0ZWd5IHwgbnVsbFxuICBpZiAodmFyaWF0aW9uU3RyYXRlZ3kpIHN0YXRlLnZhcmlhdGlvblN0cmF0ZWd5ID0gdmFyaWF0aW9uU3RyYXRlZ3lcblxuICAvLyBJZiBhdXRvU3R5bGU9dHJ1ZSBPUiBzdHlsZU1vZGU9c2VlZGVkLCBpZ25vcmUgZXhwbGljaXQgdGhlbWUvdG9rZW5zIChmcm9udGVuZCB3aWxsIGRlcml2ZSlcbiAgY29uc3QgYWxsb3dFeHBsaWNpdCA9ICEoYXV0b1N0eWxlID09PSB0cnVlIHx8IHN0eWxlTW9kZSA9PT0gJ3NlZWRlZCcpXG5cbiAgaWYgKGFsbG93RXhwbGljaXQpIHtcbiAgICBpZiAodGhlbWUpIHN0YXRlLnRoZW1lID0gdGhlbWVcbiAgICBjb25zdCB0b2tlbnM6IFRoZW1lVG9rZW5zID0ge31cbiAgICBpZiAoYWNjZW50KSB0b2tlbnMuYWNjZW50ID0gYWNjZW50XG4gICAgaWYgKHJhZGl1cykgdG9rZW5zLnJhZGl1cyA9IHJhZGl1c1xuICAgIGlmIChmb250KSB0b2tlbnMuZm9udCA9IGZvbnRcbiAgICBpZiAoT2JqZWN0LmtleXModG9rZW5zKS5sZW5ndGggPiAwKSBzdGF0ZS50aGVtZVRva2VucyA9IHRva2Vuc1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogQnVpbGQgYSBmdWxsIHNoYXJlYWJsZSBVUkwgYnkgYXBwZW5kaW5nIHRoZSBlbmNvZGVkIHF1ZXJ5IHRvIGEgYmFzZSBVUkwuXG4gKiBJZiBiYXNlIGFscmVhZHkgaGFzIGEgcXVlcnksIGl0IHdpbGwgYmUgcmVwbGFjZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNoYXJlVVJMKGJhc2VVcmw6IHN0cmluZywgc3RhdGU6IFVJU3RhdGUpOiBzdHJpbmcge1xuICBjb25zdCBxID0gZW5jb2RlU3RhdGVUb1F1ZXJ5KHN0YXRlKVxuICBjb25zdCBoYXNIYXNoID0gYmFzZVVybC5pbmNsdWRlcygnIycpID8gYmFzZVVybC5pbmRleE9mKCcjJykgOiAtMVxuICBjb25zdCBbYmVmb3JlSGFzaCwgaGFzaF0gPSBoYXNIYXNoID49IDAgPyBbYmFzZVVybC5zbGljZSgwLCBoYXNIYXNoKSwgYmFzZVVybC5zbGljZShoYXNIYXNoKV0gOiBbYmFzZVVybCwgJyddXG4gIGNvbnN0IGJhc2VOb1F1ZXJ5ID0gYmVmb3JlSGFzaC5zcGxpdCgnPycpWzBdXG4gIGNvbnN0IHNlcCA9IGJhc2VOb1F1ZXJ5LmluY2x1ZGVzKCc/JykgPyAnJyA6ICc/J1xuICByZXR1cm4gYCR7YmFzZU5vUXVlcnl9JHtzZXB9JHtxfSR7aGFzaH1gXG59XG4iXSwibmFtZXMiOlsiZW5jb2RlU3RhdGVUb1F1ZXJ5Iiwic3RhdGUiLCJzcCIsIlVSTFNlYXJjaFBhcmFtcyIsInRyaW1tZWRQcm9tcHQiLCJwcm9tcHQiLCJ0cmltIiwic2V0Iiwic2VlZCIsIk51bWJlciIsImlzRmluaXRlIiwiU3RyaW5nIiwibW9kZSIsInN0eWxlTW9kZSIsImF1dG9TdHlsZSIsImF1dG8iLCJ0aGVtZSIsInRoZW1lVG9rZW5zIiwiYWNjZW50IiwicmFkaXVzIiwiZm9udCIsInZhcmlhdGlvblN0cmF0ZWd5IiwidG9TdHJpbmciLCJwYXJzZVF1ZXJ5VG9TdGF0ZSIsInFzIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZ2V0Qm9vbCIsImtleSIsImhhcyIsInVuZGVmaW5lZCIsInYiLCJnZXQiLCJ0b0xvd2VyQ2FzZSIsImxlbmd0aCIsInNlZWRSYXciLCJuIiwiYWxsb3dFeHBsaWNpdCIsInRva2VucyIsIk9iamVjdCIsImtleXMiLCJidWlsZFNoYXJlVVJMIiwiYmFzZVVybCIsInEiLCJoYXNIYXNoIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwiYmVmb3JlSGFzaCIsImhhc2giLCJiYXNlTm9RdWVyeSIsInNwbGl0Iiwic2VwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/urlState.ts\n"));

/***/ })

});